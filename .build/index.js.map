{
  "version": 3,
  "sources": ["../index.ts"],
  "sourcesContent": ["import WebSocket, { WebSocketServer } from \"ws\";\nimport Database from \"@replit/database\";\nimport readline from \"readline\";\nimport {\n  ClientMessage,\n  ServerMessage,\n  User,\n  UserStatus\n} from \"./types\";\nimport fetchRemixicons from \"./remixicon\";\n\nconst wss = new WebSocketServer({ port: 8080 });\nconst db = new Database();\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\ntype UserConnection = {\n  webSocket: WebSocket;\n  user?: User;\n}\n\nlet onlineUsers: UserConnection[] = [];\nlet messages: any[] = [];\nconst MAX_MESSAGES = 1000;\nconst MESSAGES_PER_PAGE = 10;\n\nfunction send(message: ServerMessage, ws: WebSocket) {\n  ws.send(JSON.stringify(message));\n}\n\nfunction sendToAll(message: ServerMessage, author: WebSocket) {\n  onlineUsers\n    .filter((user) => user.webSocket !== author)\n    .forEach((user) => user.webSocket.send(JSON.stringify(message)));\n}\n\nfunction sendMessages(to: number, ws: WebSocket) {\n  const from = Math.max(0, to - MESSAGES_PER_PAGE);\n  send({\n    type: \"messages\",\n    messages: messages.slice(from, to),\n    start: !from,\n  }, ws);\n}\n\nfunction prompt() {\n  rl.question(\"> \", function (command) {\n    switch (command) {\n      case \"clear\":\n        db.set(\"messages\", \"[]\");\n        messages = [];\n        console.log(\"Cleared messages\");\n        break;\n      case \"count\":\n        console.log(messages.length);\n        break;\n      case \"messages\":\n        console.log(messages);\n        break;\n      default:\n        console.log(\"Command not recognised.\");\n    }\n    prompt();\n  });\n}\n\nasync function init() {\n  messages = await db.get(\"messages\") || [];\n  const remixicons = await fetchRemixicons();\n\n  wss.on(\"connection\", (ws: WebSocket) => {\n    const user: UserConnection = { webSocket: ws };\n    onlineUsers.push(user);\n    send({\n      type: \"users\",\n      users: onlineUsers.map((u) => u.user).filter((u) => u),\n    }, ws);\n    \n    ws.on(\"message\", (data: Buffer) => {\n      const wsMessage = JSON.parse(data.toString()) as ClientMessage;\n\n      switch (wsMessage.type) {\n        case \"message\":\n          messages.push(wsMessage.message);\n          messages = messages.slice(0, MAX_MESSAGES)\n          db.set(\"messages\", messages);\n          sendToAll({\n            type: \"messages\",\n            messages: [wsMessage.message],\n            start: false\n          }, ws);\n          break;\n        case \"fetch\":\n          if (\"after\" in wsMessage) {\n            const i = messages.findIndex(\n              (m) => m.timestamp >= wsMessage.after\n            );\n            sendMessages(i + MESSAGES_PER_PAGE, ws);\n          } else {\n            const i = messages.findIndexLast(\n              (m) => m.timestamp <= wsMessage.before\n            );\n            sendMessages(i, ws);\n          }\n          break;\n        case \"delete\":\n          switch (wsMessage.deleteType) {\n            case \"message\":\n              messages = messages.filter(\n                (message) =>\n                  message.timestamp !== message.delete.message\n              );\n              break;\n          }\n          break;\n        case \"user\":\n          console.log(\"Set user\", wsMessage.user)\n          user.user = wsMessage.user;\n          sendToAll({\n            type: \"users\",\n            users: [wsMessage.user],\n          }, ws);\n          break;\n      }\n    });\n    \n    ws.on(\"close\", () => {\n      if (user.user) {\n        user.user.status = UserStatus.OFFLINE;\n        sendToAll({\n          type: \"users\",\n          users: [user.user],\n        }, ws);\n      }\n      onlineUsers = onlineUsers.filter((s) => s.webSocket !== ws);\n    });\n  });\n  \n  prompt();\n}\n\ninit();"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA,gBAA2C;AAC3C,sBAAqB;AACrB,sBAAqB;AACrB,mBAKO;AACP,uBAA4B;AAE5B,MAAM,MAAM,IAAI,0BAAgB,EAAE,MAAM;AACxC,MAAM,KAAK,IAAI;AACf,MAAM,KAAK,wBAAS,gBAAgB;AAAA,EAClC,OAAO,QAAQ;AAAA,EACf,QAAQ,QAAQ;AAAA;AAQlB,IAAI,cAAgC;AACpC,IAAI,WAAkB;AACtB,MAAM,eAAe;AACrB,MAAM,oBAAoB;AAE1B,cAAc,SAAwB,IAAe;AACnD,KAAG,KAAK,KAAK,UAAU;AAAA;AAGzB,mBAAmB,SAAwB,QAAmB;AAC5D,cACG,OAAO,CAAC,SAAS,KAAK,cAAc,QACpC,QAAQ,CAAC,SAAS,KAAK,UAAU,KAAK,KAAK,UAAU;AAAA;AAG1D,sBAAsB,IAAY,IAAe;AAC/C,QAAM,OAAO,KAAK,IAAI,GAAG,KAAK;AAC9B,OAAK;AAAA,IACH,MAAM;AAAA,IACN,UAAU,SAAS,MAAM,MAAM;AAAA,IAC/B,OAAO,CAAC;AAAA,KACP;AAAA;AAGL,kBAAkB;AAChB,KAAG,SAAS,MAAM,SAAU,SAAS;AACnC,YAAQ;AAAA,WACD;AACH,WAAG,IAAI,YAAY;AACnB,mBAAW;AACX,gBAAQ,IAAI;AACZ;AAAA,WACG;AACH,gBAAQ,IAAI,SAAS;AACrB;AAAA,WACG;AACH,gBAAQ,IAAI;AACZ;AAAA;AAEA,gBAAQ,IAAI;AAAA;AAEhB;AAAA;AAAA;AAIJ,sBAAsB;AACpB,aAAW,MAAM,GAAG,IAAI,eAAe;AACvC,QAAM,aAAa,MAAM;AAEzB,MAAI,GAAG,cAAc,CAAC,OAAkB;AACtC,UAAM,OAAuB,EAAE,WAAW;AAC1C,gBAAY,KAAK;AACjB,SAAK;AAAA,MACH,MAAM;AAAA,MACN,OAAO,YAAY,IAAI,CAAC,MAAM,EAAE,MAAM,OAAO,CAAC,MAAM;AAAA,OACnD;AAEH,OAAG,GAAG,WAAW,CAAC,SAAiB;AACjC,YAAM,YAAY,KAAK,MAAM,KAAK;AAElC,cAAQ,UAAU;AAAA,aACX;AACH,mBAAS,KAAK,UAAU;AACxB,qBAAW,SAAS,MAAM,GAAG;AAC7B,aAAG,IAAI,YAAY;AACnB,oBAAU;AAAA,YACR,MAAM;AAAA,YACN,UAAU,CAAC,UAAU;AAAA,YACrB,OAAO;AAAA,aACN;AACH;AAAA,aACG;AACH,cAAI,WAAW,WAAW;AACxB,kBAAM,IAAI,SAAS,UACjB,CAAC,MAAM,EAAE,aAAa,UAAU;AAElC,yBAAa,IAAI,mBAAmB;AAAA,iBAC/B;AACL,kBAAM,IAAI,SAAS,cACjB,CAAC,MAAM,EAAE,aAAa,UAAU;AAElC,yBAAa,GAAG;AAAA;AAElB;AAAA,aACG;AACH,kBAAQ,UAAU;AAAA,iBACX;AACH,yBAAW,SAAS,OAClB,CAAC,YACC,QAAQ,cAAc,QAAQ,OAAO;AAEzC;AAAA;AAEJ;AAAA,aACG;AACH,kBAAQ,IAAI,YAAY,UAAU;AAClC,eAAK,OAAO,UAAU;AACtB,oBAAU;AAAA,YACR,MAAM;AAAA,YACN,OAAO,CAAC,UAAU;AAAA,aACjB;AACH;AAAA;AAAA;AAIN,OAAG,GAAG,SAAS,MAAM;AACnB,UAAI,KAAK,MAAM;AACb,aAAK,KAAK,SAAS,wBAAW;AAC9B,kBAAU;AAAA,UACR,MAAM;AAAA,UACN,OAAO,CAAC,KAAK;AAAA,WACZ;AAAA;AAEL,oBAAc,YAAY,OAAO,CAAC,MAAM,EAAE,cAAc;AAAA;AAAA;AAI5D;AAAA;AAGF;",
  "names": []
}
